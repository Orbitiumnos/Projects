#1

'''
Съемочные дни
ограничение по времени на тест2 секунды 
ограничение по памяти на тест256 мегабайт
вводстандартный ввод
выводстандартный вывод
Вы помогаете знаменитому режиссеру со съемками нового фильма. Недавно для съемок одной очень важной сцены он попросил вас выбрать два различных таких дня, что температуры в эти два дня отличаются не более чем на 5.

Вы знаете прогноз погоды на ближайшие n дней, а именно: вам заданы n целых чисел t1, t2, ..., tn, где ti равно температуре в день номер i. Для двух дней съемок x и y должно выполняться |tx - ty| ≤ 5.

Вы также знаете, что режиссер не любит долго отдыхать, поэтому хотите выбрать такие два дня, чтобы длительность периода между ними была как можно меньше.

Выведите минимальное количество дней, сколько режиссёр будет вынужден отдыхать между двумя днями съемки. Если среди n дней невозможно выбрать пару подходящих дней для съемки, то выведите -1.

Входные данные
В первой строке входных данных задано одно целое число n (2 ≤ n ≤ 100) — количество дней.

Во второй строке входных данных задано n целых чисел t1, t2, ..., tn ( - 50 ≤ ti ≤ 50), где ti равно температуре в i-й день.

Выходные данные
Если среди заданных n дней не существует пары дней с температурой, отличающейся не более чем на 5, то выведите «-1». В противном случае выведите минимальный период отдыха между днями съемки (в днях) при оптимальном выборе двух дней съемки.

Примеры
входные данные
5
4 12 -5 8 14
выходные данные
1
входные данные
3
20 20 20
выходные данные
0
входные данные
4
-20 -14 -8 -2
выходные данные
-1
Примечание
В первом примере съемки можно провести в день 2 и 4.

Во втором примере съемки можно провести в день 1 и 2.

Во третьем примере невозможно выбрать пару дней x и y, которые удовлетворяют условию |tx - ty| ≤ 5.
'''

n = input()
l = list(map(int,input().split()))
minim = -1

def findmin(dur, minim):
    if minim == -1:
        minim = dur
    else:
        if minim >= dur:
            minim = dur
    return minim

for i in range(len(l)-1):
    for j in range(i+1,len(l)):
        dif = abs(l[i] - l[j])
        if dif<=5:
            dur = abs(j-i-1)
            minim = findmin(dur,minim)
print(minim)


#2
'''
Круглый стол
ограничение по времени на тест2 секунды 
ограничение по памяти на тест256 мегабайт
вводстандартный ввод
выводстандартный вывод
За круглым столом сидят n людей из разных компаний. Люди пронумерованы от 1 до n по часовой стрелке. Человек с номером i относится к компании ai.

Скоро начнется совещание и Вам необходимо выдать каждому из n людей микрофон. В Вашем распоряжении есть бесконечное количество микрофонов любых возможных цветов. По эстетическим соображениям, человеку с номером i не понравится, если хотя бы один из его соседей слева или справа будет относиться к другой компании и при этом будет иметь микрофон того же цвета, что и человек с номером i.

Люди сидят по кругу и пронумерованы так, что:

для всех людей, кроме человека с номером 1, соседом слева является человек, имеющий номер на единицу меньше, а для человека с номером 1 соседом слева является человек с номером n;
для всех людей, кроме человека с номером n, соседом справа является человек, имеющий номер на единицу больше, а для человека с номером n соседом справа является человек с номером 1.
Ваша задача — раздать микрофоны таким образом, чтобы минимизировать количество различных использованных цветов. Если Вы используете ровно k различных цветов, то цвета микрофонов должны быть пронумерованы от 1 до k.

Входные данные
Первая строка входных данных содержит одно целое число n (3 ≤ n ≤ 2·105) — количество людей на совещании.

Вторая строка входных данных содержит n целых чисел a1, a2, ..., an (1 ≤ ai ≤ 2·105), где ai равно компании, к которой принадлежит человек с номером i.

Выходные данные
В первой строке выведите одно целое число k — минимально возможное количество различных цветов микрофонов.

Во второй строке входных данных выведите n целых чисел c1, c2, ..., cn (1 ≤ ci ≤ k), разделенных пробелами и/или переводами строк, где ci обозначает номер цвета микрофона, который необходимо отдать i-му человеку. Если существует несколько возможных ответов, вы можете вывести любой из них. Стоит заметить, что минимально возможное количество цветов микрофонов различным быть не может.

Примеры
входные данные
5
1 2 1 2 2
выходные данные
2
1 2 1 2 2
входные данные
6
1 2 2 1 2 2
выходные данные
2
2 1 2 1 2 1
входные данные
5
1 2 1 2 3
выходные данные
3
2 3 2 3 1
входные данные
3
10 10 10
выходные данные
1
1 1 1 
'''

#2
# 1 2 1 2 3

#n = int(input())
l = list(map(int,input().split()))
l2 = [1] * len(l)
c = [1]

def choose(c,col):
    c.append(c[-1]+1)
    for i in range(len(c)):
        if c[i] != col:
            return(c[i])

for i in range(1,len(l)-1):
    if l[i] != l[i-1]:
        col = l2[i-1]
        l2[i] = choose(c,col)

        print(l,l2)

#3
'''
Декодирование перестановки
ограничение по времени на тест2 секунды 
ограничение по памяти на тест256 мегабайт
вводстандартный ввод
выводстандартный вывод
Авторами была загадана перестановка p[1... n] целых чисел от 1 до n. Напомним, что перестановкой целых чисел от 1 до n называется массив длины n, в котором каждое число от 1 до n встречается ровно один раз. Например, следующие массивы являются перестановками: [3, 2, 1], [1, 4, 2, 3], [1] и [2, 1]. Следующие массивы перестановками не являются: [1, 0, 2], [1, 1, 2, 2], [1, 3, 4] и [2, 3, 4].

Для заданной перестановки p[1... n] её кодом является такой массив a длины n, что элемент ai вычисляется следующим образом: рассмотрим все индексы j такие, что pj > pi, тогда ai равен сумме значений |i - j|. Проще, ai равно сумме расстояний от элемента перестановки на позиции i до всех элементов больших него.

Например, для перестановки p = [1, 3, 2, 4, 5] её код a = [10, 5, 4, 1, 0]:

a1 = 1 + 2 + 3 + 4 = 10 (все элементы правее больше p1);
a2 = 2 + 3 = 5 (только p4 и p5 больше p2);
a3 = 1 + 1 + 2 = 4 (все элементы кроме p1 больше p3);
a4 = 1 (только p5 больше p4);
a5 = 0 (нет элементов больше p5).
Вам необходимо декодировать заданный код a, то есть восстановить соответствующую перестановку p. Гарантируется, что ответ существует и единственен.

Входные данные
Первая строка входных данных содержит одно целое число n (1 ≤ n ≤ 100) — количество элементов в перестановке p и массиве a.

Вторая строка входных данных содержит n целых чисел a1, a2, ..., an (0 ≤ ai ≤ 104), где ai равно i-му элементу массива a.

Гарантируется, что заданный массив a был построен по какой-то существующей перестановке целых чисел от 1 до n.

Выходные данные
В единственной строке выведите n целых чисел p1, p2, ..., pn (1 ≤ pi ≤ n), где pi равно i-му элементу изначальной перестановки. Заметьте, что выведенная перестановка должна соответстовать массиву a из входных данных.

Примеры
входные данные
5
10 5 4 1 0
выходные данные
1 3 2 4 5 
входные данные
1
0
выходные данные
1 
входные данные
10
30 37 20 25 7 19 18 0 1 8
выходные данные
5 1 6 2 8 3 4 10 9 7 
'''

#3

#30 37 20 25 7 19 18 0  1 8
#5  1  6  2  8 3  4  10 9 7

#n = int(input())
l = list(map(int,input().split()))
l2 = [1] * len(l)


for j in range(len(l)):
    
    res = l.index(0)
    l2[res] = l2[res] * len(l)-j
    
    for i in range(len(l)):
        l[i] = l[i]-abs(res-i)
    
    
    l[res] = l[res] - 1
        
print(' '.join(map(str,l2)))

#4
Удаление файлов
ограничение по времени на тест2 секунды 
ограничение по памяти на тест256 мегабайт
вводстандартный ввод
выводстандартный вывод
Вы сидите за своим рабочим местом и видите перед собой корневую директорию вашей рабочей станции /. У вас есть ровно n ненужных файлов и вы очень хотите побыстрее от них избавиться, ведь поддерживать порядок на рабочем месте очень важно.

Путь до каждого файла описывается последовательностью в дереве каталогов в привычной форме. Первой директорией в пути каждого файла, конечно же, является корневая директория /, далее следуют поддиректории, разделенные символом «слэш» ('/'). После последнего слэша следует название файла. Примером пути до какого-либо файла может быть /etc/sysconfig/certbot. В этой задаче не бывает таких путей, в которых идут несколько слэшей подряд (то есть путь /etc//file не является корректным), или таких, где путь заканчивается на слэш. Также не существует двух одинаковых файлов, находящихся в одной и той же директории (пример: /etc/file и /etc/file), и для любой директории выполняется то, что никакой файл не может быть назван как поддиректория (пример: /etc/src/file и /etc/src).

За одну секунду вы можете:

либо перейти в поддиректорию текущей директории, если она существует (например, в примере выше поддиректорией корневой директории / является директория etc/),
либо перейти в родительскую директорию (для /etc/sysconfig это /etc, из корневой директории / переходить в родительскую директорию нельзя),
либо удалить любой из файлов, находящийся в текущей директории.
Заметьте, что вы можете удалять только файлы, находящиеся в текущей директории. Директории удалять нельзя.

Ваша задача — удалить все n файлов за минимально возможное суммарное время.

Входные данные
Первая строка входных данных содержит одно целое число n (1 ≤ n ≤ 200) — количество файлов, которые необходимо удалить.

Следующие n строк содержат описания файлов, в каждой строке ровно по одному описанию. Файлы записаны в следующем формате: сначала следует корневая директория /, затем идет последовательность в дереве каталогов, где названия папок и имя файла разделены слэшами. Несколько слэшей подряд быть не может. После последнего слэша идет название файла без указания расширения. Название каждой директории и каждого файла содержит не менее 1 и не более 8 символов и состоит только из строчных букв латинского алфавита. Таким образом, между каждой парой соседних слэшей (а также после последнего) находится от 1 до 8 букв латинского алфавита. Гарантируется, что каждый файл имеет вложенность не более 200 (таким образом, в пути до этого файла находится не более 200 слэшей). Гарантируется, что не существует двух одинаковых файлов, находящихся в одной и той же директории (пример: /etc/file и /etc/file), и для любой директории выполняется то, что никакой файл не может быть назван как поддиректория (пример: /etc/src/file и /etc/src).

Выходные данные
Выведите одно целое число — минимально возможное время, необходимое для того, чтобы удалить все n файлов из заданного списка.

Примеры
входные данные
5
/etc/sudoers
/root/readme
/etc/zshrc
/bin/curl
/etc/ntp/keys
выходные данные
11
входные данные
2
/readme
/make
выходные данные
2
входные данные
5
/a/b/c
/a/b/a
/a/a
/a/c/a
/b/a/a
выходные данные
13
Примечание
В первом тестовом примере наиболее выгодным путем будет зайти в папку /root за одну секунду, удалить из один файл за одну секунду, вернуться в родительскую директорию, зайти в папку bin за одну секунду, удалить из нее один файл также за одну секунду, вернуться в родительскую директорию, зайти в /etc, удалить два файла за две секунды, затем зайти в /etc/ntp и удалить последний файл. Таким образом, ответ равен (1 + 1 + 1) + (1 + 1 + 1) + (1 + 2 + 1 + 1) = 11.
